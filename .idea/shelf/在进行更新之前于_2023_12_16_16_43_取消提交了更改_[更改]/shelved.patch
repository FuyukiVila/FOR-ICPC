Index: test/test.cpp
===================================================================
diff --git a/test/test.cpp b/test/test.cpp
deleted file mode 100644
--- a/test/test.cpp	(revision 673774b3884bb10c2bbb8111491f72cf2146aafb)
+++ /dev/null	(revision 673774b3884bb10c2bbb8111491f72cf2146aafb)
@@ -1,43 +0,0 @@
-#include <stdio.h>
-
-template<typename T>
-void print_int(T t) {
-    printf("%d %#x\n", (int) t, (int) t);
-}
-
-template<typename T>
-void print_short(T t) {
-    printf("%hd %#x\n", (short) t, (short) t);
-}
-
-template<typename T>
-void print_unsignedShort(T t) {
-    printf("%u %#x\n", (unsigned short) t, (unsigned short) t);
-}
-
-template<typename T>
-void print_unsignedInt(T t) {
-    printf("%u %#x\n", (unsigned int) t, (unsigned int) t);
-}
-
-template<typename T>
-void print_float(T t) {
-    float f = t;
-    printf("%f %#x\n", (float) t, *(unsigned int *) &f);
-}
-
-template<typename T>
-void print_double(T t) {
-    double f = t;
-    printf("%lf %#x\n", (double) t, *(unsigned long long *) &f);
-}
-
-int main() {
-    short a = -12345;
-    int b = 2147483647;
-    float c = 123456.789e5;
-    double d = 123456.789e5;
-    printf("x = %lf\n", d);
-    print_double(d);
-    print_float(d);
-}
\ No newline at end of file
Index: test/B.cpp
===================================================================
diff --git a/test/B.cpp b/test/B.cpp
deleted file mode 100644
--- a/test/B.cpp	(revision 673774b3884bb10c2bbb8111491f72cf2146aafb)
+++ /dev/null	(revision 673774b3884bb10c2bbb8111491f72cf2146aafb)
@@ -1,24 +0,0 @@
-#include<bits/stdc++.h>
-
-#define ll long long
-#define PII pair<int,int>
-#define endl '\n'
-#define i128 __int128_t
-#define umap unordered_map
-using namespace std;
-const int maxn = 2e5 + 9;
-int a[maxn], b[maxn];
-int vp[maxn];
-
-void solve(){
-
-}
-
-signed main() {
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    int t = 1;
-    cin >> t;
-    while (t--) solve();
-    return 0;
-}
\ No newline at end of file
Index: test/C.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test/C.cpp b/codeforces/contest1902/B.cpp
rename from test/C.cpp
rename to codeforces/contest1902/B.cpp
--- a/test/C.cpp	(revision 673774b3884bb10c2bbb8111491f72cf2146aafb)
+++ b/codeforces/contest1902/B.cpp	(date 1702715830084)
@@ -6,7 +6,7 @@
 |  | |_ | |   __|  |  . `  |     \   \    |   __   | |  | |  . `  |    |  | |  |\/|  | |   ___/  /  /_\  \  |  |         |  |
 |  |__| | |  |____ |  |\   | .----)   |   |  |  |  | |  | |  |\   |    |  | |  |  |  | |  |     /  _____  \ |  `----.    |  |
  \______| |_______||__| \__| |_______/    |__|  |__| |__| |__| \__|    |__| |__|  |__| | _|    /__/     \__\ \______|    |__|
-
+ 
 □□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□□□□□□
 □□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□
 □□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
@@ -69,6 +69,7 @@
 
 #define GKD std::cin.tie(nullptr)->std::ios::sync_with_stdio(false)
 #define clr(a, b) memset(a, b, sizeof(a))
+#define cpy(a, b) memcpy(a, b, sizeof(a));
 
 #include <bits/stdc++.h>
 
@@ -97,7 +98,7 @@
 using uset = unordered_set<T>;
 const double pi = acos(-1);
 const int INF = 0x3f3f3f3f;
-const int mod = 0;
+ll mod = 0;
 
 inline ll qpow(ll _a, ll _n, ll _mod = mod) {
     ll ans = 1;
@@ -134,98 +135,53 @@
 std::default_random_engine eng(rd());
 std::uniform_int_distribution<ll> ranint(1, 1e18);
 
-struct node {
-    ll num;
-    int id;
-
-    bool operator<(const node &a) const {
-        return num < a.num;
-    }
-};
-
+//玩原神导致的
 void genshin_start() {
-    ll n, maxn, cf, cm, m;
-    cin >> n >> maxn >> cf >> cm >> m;
-    vector<node> a(n + 3);
+    int n;
+    cin >> n;
+    auto a = *new vector<int>(n + 1);
+    auto mp = *new map<int, bool>;
     for (int i = 1; i <= n; i++) {
-        cin >> a[i].num;
-        a[i].id = i;
+        cin >> a[i];
+        mp[a[i]] = true;
     }
-    ll lowest = 0, maxncnt = 0;
+    if (n == 1) {
+        cout << "1\n";
+        return;
+    }
+    sort(a.begin() + 1, a.end());
     ll ans = 0;
-    ll tmp = 0;
-    sort(a.begin() + 1, a.begin() + n + 1);
-    vector<ll> sum(n + 3);
+    int g = 0;
+    for (int i = 2; i <= n; i++) {
+        if (a[i] - a[i - 1] != 0) {
+            if (g == 0) {
+                g = a[i] - a[i - 1];
+            } else if (a[i] - a[i - 1] != 0) {
+                g = __gcd(g, a[i] - a[i - 1]);
+            }
+        }
+    }
+    if (g == 0) {
+        cout << "1\n";
+        return;
+    }
     for (int i = 1; i <= n; i++) {
-        sum[i] = sum[i - 1] + a[i].num;
+        ans += (a[n] - a[i]) / g;
     }
-    for (int i = n + 1; i >= 1; i--) {
-        if (i <= n)tmp += maxn - a[i].num;
-        if (tmp > m) {
+    ll __ans = ans + n;
+    for (int i = 1; i <= n; i++) {
+        if (!mp[a[n] - i * g]) {
+            ans += i;
             break;
         }
-        if (i == 1) {
-            if (n * cf + cm * maxn > ans) {
-                lowest = maxn;
-                maxncnt = n;
-                ans = n * cf + cm * maxn;
-            }
-            break;
-        }
-        ll l = a[1].num, r = maxn - 1;
-        while (l <= r) {
-            ll mid = (l + r) >> 1; // 最低等级为mid
-            if (a[i - 1].num <= mid) {
-                if (mid * (i - 1) - sum[i - 1] + tmp <= m) {
-                    if (mid * cm + (n - i + 1) * cf > ans) {
-                        ans = mid * cm + (n - i + 1) * cf;
-                        lowest = mid;
-                        maxncnt = n - i + 1;
-                    }
-                    l = mid + 1;
-                } else {
-                    r = mid - 1;
-                }
-            }
-            node p;
-            p.num = mid, p.id = 0;
-            int pos = upper_bound(a.begin() + 1, a.begin() + i, p) - a.begin();
-            pos--;
-            if (mid * pos - sum[pos] + tmp <= m) {
-                if (mid * cm + (n - i + 1) * cf > ans) {
-                    ans = mid * cm + (n - i + 1) * cf;
-                    lowest = mid;
-                    maxncnt = n - i + 1;
-                }
-                l = mid + 1;
-            } else {
-                r = mid - 1;
-            }
-        }
-    }
-
-    cout << ans << '\n';
-    for (int i = 1; i <= n; i++) {
-        if (i >= n - maxncnt + 1) {
-            a[i].num = maxn;
-        } else if (a[i].num <= lowest) {
-            a[i].num = lowest;
-        }
-    }
-
-    sort(a.begin() + 1, a.begin() + n + 1, [&](const node &a, const node &b) { return a.id < b.id; });
-    for (int i = 1; i <= n; i++) {
-        cout << a[i].num << ' ';
-    }
-
-
+    }
+    cout << min(ans, __ans) << '\n';
 }
 
 signed main() {
-//    GKD;
+    GKD;
     auto T = 1;
-//    cin >> T;
+    cin >> T;
     while (T--) genshin_start();
     return 0;
-}
-
+}
\ No newline at end of file
Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/.vscode/\r\n/.idea/\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gitignore b/.gitignore
--- a/.gitignore	(revision 673774b3884bb10c2bbb8111491f72cf2146aafb)
+++ b/.gitignore	(date 1702716020639)
@@ -1,2 +1,3 @@
 /.vscode/
 /.idea/
+/test/
\ No newline at end of file
Index: test/E.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test/E.cpp b/codeforces/contest1902/D.cpp
rename from test/E.cpp
rename to codeforces/contest1902/D.cpp
--- a/test/E.cpp	(revision 673774b3884bb10c2bbb8111491f72cf2146aafb)
+++ b/codeforces/contest1902/D.cpp	(date 1702715830085)
@@ -6,7 +6,7 @@
 |  | |_ | |   __|  |  . `  |     \   \    |   __   | |  | |  . `  |    |  | |  |\/|  | |   ___/  /  /_\  \  |  |         |  |
 |  |__| | |  |____ |  |\   | .----)   |   |  |  |  | |  | |  |\   |    |  | |  |  |  | |  |     /  _____  \ |  `----.    |  |
  \______| |_______||__| \__| |_______/    |__|  |__| |__| |__| \__|    |__| |__|  |__| | _|    /__/     \__\ \______|    |__|
-
+ 
 □□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□□□□□□
 □□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□
 □□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
@@ -69,6 +69,7 @@
 
 #define GKD std::cin.tie(nullptr)->std::ios::sync_with_stdio(false)
 #define clr(a, b) memset(a, b, sizeof(a))
+#define cpy(a, b) memcpy(a, b, sizeof(a));
 
 #include <bits/stdc++.h>
 
@@ -134,182 +135,108 @@
 std::default_random_engine eng(rd());
 std::uniform_int_distribution<ll> ranint(1, 1e18);
 
-#include <bits/stdc++.h>
-
-using namespace std;
-
-template<typename T>
-class SegTree {
-private:
-    struct node {
-        T value{0};
-        T add{0};
-        T change{0};
-        bool isChange{false};
-        int l{0}, r{0};
-
-        constexpr bool inRange(int l, int r) {
-            return this->l >= l && this->r <= r;
-        }
-
-        constexpr bool outOfRange(int l, int r) {
-            return this->l > r || this->r < l;
-        }
-
-        constexpr int length() {
-            return this->r - this->l + 1;
-        }
-
-        constexpr int size() {
-            return length();
-        }
-
-    };
-
-    vector<node> tree;
-    int n, n4;
-
-
-    void push_down(int x) {
-        //push down操作
-        //区间求和
-        if (tree[x].isChange) {
-            tree[x * 2].value = tree[x].change * tree[x * 2].size();
-            tree[x * 2 + 1].value = tree[x].change * tree[x * 2 + 1].size();
-            tree[x * 2].change = tree[x * 2 + 1].change = tree[x].change;
-            tree[x * 2].isChange = tree[x * 2 + 1].isChange = true;
-        }
-        if (tree[x].add) {
-            tree[x * 2].value += tree[x].add * tree[x * 2].size();
-            tree[x * 2 + 1].value += tree[x].add * tree[x * 2 + 1].size();
-            tree[x * 2].add += tree[x].add;
-            tree[x * 2 + 1].add += tree[x].add;
-        }
-        //区间求max
-//        if (tree[x].change) {
-//            tree[x * 2].value = tree[x].change;
-//            tree[x * 2 + 1].value = tree[x].change;
-//            tree[x * 2].change = tree[x * 2 + 1].change = tree[x].change;
-//            tree[x * 2].isChange = tree[x * 2 + 1].isChange = true;
-//        }
-//        if (tree[x].add) {
-//            tree[x * 2].value += tree[x].add;
-//            tree[x * 2 + 1].value += tree[x].add;
-//            tree[x * 2].add += tree[x].add;
-//            tree[x * 2 + 1].add += tree[x].add;
-//        }
-
-        tree[x].isChange = tree[x].change = tree[x].add = 0;
-
-    }
-
-    void push_up(int x) {
-        //push up操作
-        //区间求和
-        tree[x].value = tree[2 * x].value + tree[2 * x + 1].value;
-//        区间求max
-//        tree[x].value = max(tree[2 * x].value, tree[2 * x + 1].value);
-    }
-
-    void build(const vector<T> &arr, int x, int l, int r) {
-        tree[x].l = l, tree[x].r = r;
-        if (l == r) {
-            tree[x].value = arr[l];
-            return;
-        }
-        int m = (l + r) >> 1;
-        build(arr, x * 2, l, m);
-        build(arr, x * 2 + 1, m + 1, r);
-        push_up(x);
-    }
-
-public:
-    explicit SegTree(const vector<T> &arr) {
-        n = arr.size() - 1;
-        n4 = n * 4;
-        tree.resize(n4 + 5);
-        build(arr, 1, 1, n);
-    }
-
-    void add(int l, int r, T val, int x = 1) {
-        if (tree[x].outOfRange(l, r)) {
-            return;
-        }
-        if (tree[x].inRange(l, r)) {
-            tree[x].add += val;
-            tree[x].value += val * tree[x].size();
-            return;
-        }
-        push_down(x);
-        add(l, r, val, x * 2);
-        add(l, r, val, x * 2 + 1);
-        push_up(x);
-    }
-
-    void change(int l, int r, T val, int x = 1) {
-        if (tree[x].outOfRange(l, r)) {
-            return;
-        }
-        if (tree[x].inRange(l, r)) {
-            tree[x].isChange = true;
-            tree[x].add = 0;
-            tree[x].change = val;
-            tree[x].value = val * tree[x].size();
-            return;
-        }
-        push_down(x);
-        change(l, r, val, x * 2);
-        change(l, r, val, x * 2 + 1);
-        push_up(x);
-    }
-
-    T query(int l, int r, int x = 1) {
-        if (tree[x].outOfRange(l, r)) {
-            return 0;
-        }
-        if (tree[x].inRange(l, r)) {
-            return tree[x].value;
-        }
-        push_down(x);
-        return query(l, r, x * 2) + query(l, r, x * 2 + 1);
-//        return max(query(l, r, x * 2), query(l, r, x * 2 + 1));
-    }
-};
-
 //玩原神导致的
-void genshin_start(int testCase) {
-    int n;
-    cin >> n;
-    vector<int> a(n + 1);
+struct node {
+    int x{}, y{};
+
+    void move(char c) {
+        if (c == 'R') {
+            x += 1;
+        } else if (c == 'L') {
+            x -= 1;
+        } else if (c == 'D') {
+            y -= 1;
+        } else if (c == 'U') {
+            {
+                y += 1;
+            }
+        }
+    }
+};
+
+void genshin_start() {
+    int n, q;
+    cin >> n >> q;
+    string s;
+    cin >> s;
+    s = "#" + s;
+    node p, _p;
+    auto fi = *new map<pair<int, int>, int>;
+    auto la = *new map<pair<int, int>, int>;
+    auto mpx = *new map<int, vector<int> >;
+    auto mpy = *new map<int, vector<int> >;
+    vector<int> dx(n + 1), dy(n + 1);
     for (int i = 1; i <= n; i++) {
-        cin >> a[i];
-    }
-    unordered_map<int, int> cnt;
-    SegTree t(vector<int>(n + 1));
-    for (int i = n; i >= 1; i--) {
-        cnt[a[i]]++;
-        t.add(cnt[a[i]], cnt[a[i]], 1);
+        p.move(s[i]);
+        dx[i] = p.x;
+        dy[i] = p.y;
+        mpx[p.x].emplace_back(i);
+        mpy[p.y].emplace_back(i);
+        if (!fi[{p.x, p.y}]) {
+            fi[{p.x, p.y}] = i;
+        }
+        la[{p.x, p.y}] = i;
     }
-    unordered_map<int, int> cnt1;
-    ll ans = 0;
-    for (int i = 1; i <= n; i++) {
-        cnt1[a[i]]++;
-        int tmp = cnt[a[i]]--;
-        t.add(tmp, tmp, -1);
-//        t.add(tmp - 1, tmp - 1, 1);
-        ans += t.query(1, cnt1[a[i]] - 1);
+//    for (int i = n; i >= 1; i--) {
+//        _p.move(s[i]);
+//        px[i] = _p.x;
+//        py[i] = _p.y;
+//    }
+    for (int i = 1; i <= q; i++) {
+        int x, y, l, r;
+        cin >> x >> y >> l >> r;
+        if (x == 0 && y == 0) {
+            cout << "YES\n";
+            continue;
+        }
+        if (fi[{x, y}] != 0 && fi[{x, y}] < l) {
+            cout << "YES\n";
+            continue;
+        }
+        if (la[{x, y}] > r) {
+            cout << "YES\n";
+            continue;
+        }
+        int xx = x - dx[l - 1], yy = y - dy[l - 1];
+        xx = dx[r] - xx;
+        yy = dy[r] - yy;
+        if (xx == 0 && yy == 0) {
+            cout << "YES\n";
+            continue;
+        }
+//        if (lower_bound(mpx[xx].begin(), mpx[xx].end(), l - 1) == mpx[xx].end() ||
+//            lower_bound(mpy[yy].begin(), mpy[yy].end(), l - 1) == mpy[yy].end()) {
+//            cout << "NO\n";
+//            continue;
+//        }
+//        if (*lower_bound(mpx[xx].begin(), mpx[xx].end(), l - 1) > r ||
+//            *lower_bound(mpy[yy].begin(), mpy[yy].end(), l - 1) > r) {
+//            cout << "NO\n";
+//            continue;
+//        }
+        auto p1 = lower_bound(mpx[xx].begin(), mpx[xx].end(), l - 1),
+                p2 = lower_bound(mpy[yy].begin(), mpy[yy].end(), l - 1);
+        while (p1 != mpx[xx].end() && p2 != mpy[yy].end() && *p1 <= r && *p2 <= r) {
+            if (*p1 < *p2) {
+                p1++;
+            } else if (*p2 < *p1) {
+                p2++;
+            } else {
+                cout << "YES\n";
+                goto nextTime;
+            }
+        }
+        cout << "NO\n";
+        nextTime:;
     }
-    cout << ans << '\n';
 
 }
+
 
 signed main() {
     GKD;
-    int T = 1;
+    auto T = 1;
 //    cin >> T;
-    for (int i = 1; i <= T; i++) {
-        genshin_start(i);
-    }
+    while (T--) genshin_start();
     return 0;
-}
-
+}
\ No newline at end of file
Index: WeeklyContest/Team Weekly Contest 2023-12-2/F.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/WeeklyContest/Team Weekly Contest 2023-12-2/F.cpp b/WeeklyContest/Team Weekly Contest 2023-12-2/F.cpp
new file mode 100644
--- /dev/null	(date 1702715830080)
+++ b/WeeklyContest/Team Weekly Contest 2023-12-2/F.cpp	(date 1702715830080)
@@ -0,0 +1,454 @@
+/*
+
+  _______  _______ .__   __.      _______. __    __   __  .__   __.     __  .___  ___. .______      ___       ______ .___________.
+ /  _____||   ____||  \ |  |     /       ||  |  |  | |  | |  \ |  |    |  | |   \/   | |   _  \    /   \     /      ||           |
+|  |  __  |  |__   |   \|  |    |   (----`|  |__|  | |  | |   \|  |    |  | |  \  /  | |  |_)  |  /  ^  \   |  ,----'`---|  |----`
+|  | |_ | |   __|  |  . `  |     \   \    |   __   | |  | |  . `  |    |  | |  |\/|  | |   ___/  /  /_\  \  |  |         |  |
+|  |__| | |  |____ |  |\   | .----)   |   |  |  |  | |  | |  |\   |    |  | |  |  |  | |  |     /  _____  \ |  `----.    |  |
+ \______| |_______||__| \__| |_______/    |__|  |__| |__| |__| \__|    |__| |__|  |__| | _|    /__/     \__\ \______|    |__|
+ 
+□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□□□■■■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■■■■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■■■■■□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□□□□□□□□□■■■□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□■■□□□□□□□□□■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□□□□□□□□■■■■□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□■□□□□□□□□□■■□□□□□□□□■■■■□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□■■□□□□□■■■□□□□□□□■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□■■□□□□□□□□■■□□□□□■■■■■■■■□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□■■■□□□□■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□■■■□□□□□□□■■■■■■■■■■■■■■□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□■■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■□■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□■■■■■■■■■■■■■■■■■□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■■■■■■■□■■■■■■■■■■■■■■■■□□□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□■■■■■■■■□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■■■■■■■■■□□□■■■■■■■■■□■■□□□□□□□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■□□□□□■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■□□□□■■■■□□□■■■□□□□□□□■■□□□□□□□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■□□□□□■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□■■■■□□□□■■■□□□□□□□■■□□□□□□□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■□□□□□■■■□□□□□□□■■■■■■■■□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□■■□□□□□□□■■□□□□□□□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■■■■■■■■■■■■■■■■□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□■■□□□□□□□■■■■■■■■□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□■■□■■■■■■■■■■■■■■■□■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■■■■■■■■□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■□□□□□□■■■■■■■■■■■■■■■■□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■□□□□■■■■■■■■■■■□□□□□□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■■■□□□■■■□□□□□□■■□□□□□□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■□□□□□□□□□□□□■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■□■■■■■□□■■■□□□□□□■■□□□□□□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■□□□■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□■■■□□■■■■□□■■■□□□□□□■■□□□□□□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□■■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□■■■□□□■■■□□■■■□□□□□□■■□□□□□□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□■■■□□□□□■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□■■■□□□□■■□□■■■□□□□□□■■□□□■■■□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□■■■□□□□□□■■■■■■■□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□■■■□□□□□■□□■■■□■■■■■■■■■■■■■■■■■□□□□□□□□□□□□
+□□□□□□□□□□□□■■■□□□□□□□■■□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□■■■□□□□□□□■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□
+□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□■■■□□□□□□□■■■■■■■■■■■■■□□□□□□■■□□□□□□□□□□□□□
+□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□■■■□□□□□□□■■■■□□□□□□■■□□□□□□□■■□□□□□□□□□□□□□
+□□□□□□□□□□□■■■□□□□□□□□■■□□□□□□□■■■□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□■■■□□□□□□□□■■□□□□□□□■■□□□□□□□■■□□□□□□□□□□□□□
+□□□□□□□□□□□■■■□□□□□□□□■■■□□□□□□■■□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□□□■■■□□□□□□□□■■□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□■■■□□□□□□□□□■■■□□□□□□■■□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□■■■□□□□□□□□■■■■■□□□□□■■□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□■■■□□□□□□□■■■■■□□□□□□■■□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□■■■□□□□□□□■■■■■□□□□□□□■■□□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□■■■□□□□□□□■■■■□□□□□□□□■■□□□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□■■■□□□□□□□■■■■□□□□□□□□□■■□□□□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□■■■□□□□□□□■■■□□□□□□□□□□□■■□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□■■■□□□□□□■■■□□□□□■■□□□□□■■□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□■■■□□□□□□■■■□□□□□□■■■■□□□■■□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□■■□□□□□□■■■□□□□□□□□■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□■■■□□□□□□■■□□□□□□□□□□■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□■■□□□□□□□□□□□□□□□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□
+
+  ______                 _    _  __      ___ _
+ |  ____|               | |  (_) \ \    / (_) |
+ | |__ _   _ _   _ _   _| | ___   \ \  / / _| | __ _
+ |  __| | | | | | | | | | |/ / |   \ \/ / | | |/ _` |
+ | |  | |_| | |_| | |_| |   <| |    \  /  | | | (_| |
+ |_|   \__,_|\__, |\__,_|_|\_\_|     \/   |_|_|\__,_|
+              __/ |
+             |___/
+
+*/
+
+#define GKD std::cin.tie(nullptr)->std::ios::sync_with_stdio(false)
+#define clr(a, b) memset(a, b, sizeof(a))
+#define cpy(a, b) memcpy(a, b, sizeof(a));
+
+#include <bits/stdc++.h>
+
+#define dbg(x...) \
+    do { \
+        std::cout << #x << " -> "; \
+        err(x); \
+    } while (0)
+
+void err() {
+    std::cout << std::endl;
+}
+
+template<class T, class... Ts>
+void err(T arg, Ts &... args) {
+    std::cout << arg << ' ';
+    err(args...);
+}
+
+using namespace std;
+using ll = long long;
+using ull = unsigned long long;
+template<typename T, typename K>
+using umap = unordered_map<T, K>;
+template<typename T>
+using uset = unordered_set<T>;
+const double pi = acos(-1);
+const int INF = 0x3f3f3f3f;
+const double PI = acos(-1.0);
+constexpr double eps = 1e-7;
+constexpr int sgn(double x) {
+    if (abs(x) < eps) {
+        return 0;
+    }
+    if (x < 0) {
+        return -1;
+    } else {
+        return 1;
+    }
+}
+
+double radian(double degree) {
+    return degree * PI / 180.0;
+}
+
+namespace Dimension3 {
+    class Point {
+    public:
+        typedef Point Vector;
+        double x, y, z;
+
+        constexpr Point() : x(), y(), z() {}
+
+        constexpr Point(double x, double y, double z) : x(x), y(y), z(z) {}
+
+        //加
+        constexpr Vector operator+(const Vector &v) const {
+            return {x + v.x, y + v.y, z + v.z};
+        }
+
+        //减
+        constexpr Vector operator-(const Vector &v) const {
+            return {x - v.x, y - v.y, z - v.z};
+        }
+
+        //点积
+        constexpr double operator*(const Vector &v) const {
+            return x * v.x + y * v.y + z * v.z;
+        }
+
+        //叉积
+        constexpr Vector operator^(const Vector &v) const {
+            return {y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x};
+        }
+
+        //数乘
+        constexpr Vector operator*(double b) const {
+            return {x * b, y * b, z * b};
+        }
+
+        constexpr Vector operator/(double b) const {
+            return {x / b, y / b, z / b};
+        }
+
+        //等于
+        constexpr bool operator==(const Vector &v) const {
+            return sgn(x - v.x) == 0 && sgn(y - v.y) && sgn(z - v.z);
+        }
+
+        //绕点p逆时针旋转弧度b
+        constexpr Point &rotate(double radian, const Point &p = {0, 0, 0}) {
+            // 将点平移到原点
+            double translatedX = x - p.x;
+            double translatedY = y - p.y;
+            double translatedZ = z - p.z;
+
+            // 使用旋转矩阵进行三维旋转
+            double cosTheta = cos(radian);
+            double sinTheta = sin(radian);
+
+            double newX = translatedX * cosTheta - translatedY * sinTheta;
+            double newY = translatedX * sinTheta + translatedY * cosTheta;
+            double newZ = translatedZ;
+
+            // 将点平移到原始位置
+            x = newX + p.x;
+            y = newY + p.y;
+            z = newZ + p.z;
+
+            return *this;
+        }
+
+        //模
+        constexpr double norm() const {
+            return sqrt(*this * *this);
+        }
+
+        //点距
+        constexpr double distance(const Point &p) const {
+            return (*this - p).norm();
+        }
+
+    };
+
+    using Vector = Point;
+
+    class Line {
+    public:
+        Point a, b;
+        typedef Line Seg;
+
+        constexpr Line() : a(), b() {}
+
+        constexpr Line(const Point &a, const Point &b) : a(a), b(b) {}
+
+        //线段长度
+        constexpr double length() const {
+            return (b - a).norm();
+        }
+
+        //求点到直线的距离
+        //返回点到直线上最近的点，垂足
+        constexpr Point pointToLine(const Point &p) const {
+            Point direction = b - a;
+            Point vector = p - a;
+
+            // 使用向量的投影计算垂足的位置
+            double t = (vector * direction) / direction.norm();
+            return a + direction * (t / direction.norm());
+        }
+
+        constexpr double distance(const Point &p) const {
+            return p.distance(pointToLine(p));
+        }
+
+        constexpr double distance(const Line &l) const {
+            auto [result, intersectionPoint] = *this & l;
+            if (result == 1) {
+                return distance(l.a);
+            } else if (result == 3) {
+                return (a - l.a) * ((l.a - l.b) ^ (a - b)) / ((l.a - l.b) ^ (a - b)).norm();
+            } else {
+                return 0;
+            }
+        }
+
+        //判断点在直线上
+        constexpr bool pointOnLine(const Point &p) const {
+            return sgn(distance(p)) == 0;
+        }
+
+        //两直线相交求交点
+        //第一个值为0表示直线重合，为1表示平行,为2是相交，为3是相离
+        //只有第一个值为2时，交点才有意义
+        constexpr std::pair<int, Point> operator&(const Line &l) const {
+            Point direction1 = b - a;
+            Point direction2 = l.b - l.a;
+            // 判断两直线是否平行
+            Point crossProduct = direction1 ^ direction2;
+            if (sgn(crossProduct.norm()) == 0) {
+                // 平行或重合
+                if (pointOnLine(l.a) && pointOnLine(l.b)) {
+                    // 重合
+                    return {0, Point()};
+                } else {
+                    // 平行
+                    return {1, Point()};
+                }
+            }
+
+            // 计算参数 t1 和 t2，使得两直线上的点满足参数方程
+            double t1 = ((l.a - a) ^ direction2).norm() / crossProduct.norm();
+            double t2 = ((a - l.a) ^ direction1).norm() / crossProduct.norm();
+            // 计算交点
+            Point intersectionPoint = a + direction1 * t1;
+            if (!pointOnLine(intersectionPoint) || !l.pointOnLine(intersectionPoint)) {
+                return {3, Point()};
+            }
+            return {2, intersectionPoint};
+        }
+
+        // 判断点p是否在线段上
+        constexpr bool pointOnSeg(const Point &p) const {
+
+            // 判断点到线段两端点的投影是否在线段上，且点到线段两端点的距离之和等于线段的长度
+            return pointOnLine(p) && p.x >= min(a.x, b.x) && p.x <= max(a.x, b.x) && p.y >= min(a.y, b.y) &&
+                   p.y <= max(a.y, b.y) && p.z >= min(a.z, b.z) && p.z <= max(a.z, b.z);
+        }
+
+        // 判断线段是否相交
+        constexpr bool seg_inter_seg(const Seg &l) const {
+            auto [result, intersectionPoint] = *this & l;
+
+            if (result == 2) {
+                // 两线段相交，再判断交点是否在两线段上
+                return l.pointOnSeg(intersectionPoint) && pointOnSeg(intersectionPoint);
+            }
+
+            return false;
+        }
+
+        //判断直线与线段l是否相交
+        constexpr bool line_inter_seg(const Seg &l) const {
+            auto [result, intersectionPoint] = *this & l;
+
+            if (result == 2) {
+                // 两线段相交，再判断交点是否在线段上
+                return l.pointOnSeg(intersectionPoint);
+            }
+
+            return false;
+        }
+
+        // 求点到线段的距离，返回点到线段最近的点
+        constexpr Point nearestPointToSeg(const Point &p) const {
+            Point vectorAP = p - a;
+            Point vectorAB = b - a;
+
+            // 计算点到线段的投影位置
+            double t = (vectorAP * vectorAB) / vectorAB.norm();
+
+            // 如果投影位置小于等于0，则最近的点是线段的起点a
+            if (sgn(t) <= 0) {
+                return a;
+            }
+
+            // 如果投影位置大于等于线段长度，则最近的点是线段的终点b
+            if (sgn(t - vectorAB.norm()) >= 0) {
+                return b;
+            }
+
+            // 否则，最近的点是线段上的投影点
+            return a + vectorAB * (t / vectorAB.norm());
+        }
+    };
+
+    class Plane {
+    public:
+        Point a, b, c;
+
+        // 无参构造函数
+        constexpr Plane() : a(), b(), c() {}
+
+        // 有参构造函数
+        constexpr Plane(const Point &a, const Point &b, const Point &c) : a(a), b(b), c(c) {}
+
+        // 面到点的距离
+        constexpr double distance(const Point &p) const {
+            Point normal = (b - a) ^ (c - a);
+            double d = -normal.x * a.x - normal.y * a.y - normal.z * a.z;
+            return abs(normal.x * p.x + normal.y * p.y + normal.z * p.z + d) / normal.norm();
+        }
+
+        // 面到线的距离
+        constexpr double distance(const Line &l) const {
+            auto [res, intersectionPoint] = intersectWithLine(l);
+            if (res != 0) {
+                return 0;
+            } else {
+                return distance(l.a);
+            }
+        }
+
+        // 面到面的距离
+        constexpr double distance(const Plane &p) const {
+            auto [res, intersectionPoint] = intersectWithPlane(p);
+            if (res != 0) {
+                return 0;
+            } else {
+                return distance(p.a);
+            }
+        }
+
+        // 面和线的交点
+        constexpr pair<int, Point> intersectWithLine(const Line &line) const {
+            Point normal = (b - a) ^ (c - a);
+
+            // 如果线和面平行，返回空点
+            if (sgn((normal * (line.b - line.a)) == 0)) {
+                return {0, Point()};
+            }
+
+            // 计算交点
+            double t = -((normal.x * (line.a.x - a.x) + normal.y * (line.a.y - a.y) + normal.z * (line.a.z - a.z)) /
+                         (normal * (line.b - line.a)));
+            return {1, line.a + (line.b - line.a) * t};
+        }
+
+        // 面和面的交线，0为不存在，1为存在
+        constexpr std::pair<int, Line> intersectWithPlane(const Plane &other) const {
+            Point normal1 = (b - a) ^ (c - a);
+            Point normal2 = (other.b - other.a) ^ (other.c - other.a);
+            Point direction = normal1 ^ (normal2);
+
+            // 如果两平面平行，返回空线段
+            if (sgn(direction.norm()) == 0) {
+                return {0, Line()};
+            }
+
+            // 选择交线上的一点
+            Point pointOnLine = a;
+
+            // 计算交线的方向
+            Point lineDirection = normal1 ^ (direction);
+
+            // 计算交线的终点
+            Point endPoint = pointOnLine + lineDirection;
+
+            return {1, Line(pointOnLine, endPoint)};
+        }
+
+    };
+}
+using namespace Dimension3;
+//玩原神导致的
+void genshin_start() {
+    int x,y,z,r;
+    cin >> x >> y >> z >> r;
+    Point o(x,y,z);
+    int x1,y1,z1,x2,y2,z2;
+    cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;
+    Point s(x1,y1,z1),t(x2,y2,z2);
+    if(s.distance(t) == 0) {
+        cout << 0 << endl;
+        return;
+    }
+    Line myline(s,t);
+    if(o.distance(myline.nearestPointToSeg(o))>=r){
+        cout << myline.length()<< '\n';
+        return;
+    }
+    double dis = o.distance(myline.pointToLine(o));
+    if(dis >= r){;
+        cout << myline.length()<< endl;
+    }else {
+        double res;
+        if (s.distance(o) == r && t.distance(o) == r) {
+            double sgm = acos(dis / r);
+            res = 2 * r * (sgm);
+        } else {
+            double sgm0 = 0;
+            sgm0 += acos(dis/s.distance(o));
+            sgm0 += acos(dis/t.distance(o));
+            double sgm1 = acos(r / s.distance(o));
+            if(s.distance(o) == r) sgm1 = 0;
+            double sgm2 = acos(r / t.distance(o));
+            if(t.distance(o) == r) sgm2 = 0;
+            res = r * (sgm0 - sgm1 - sgm2) + sqrt(s.distance(o) * s.distance(o) - r * r)
+                         + sqrt(t.distance(o) * t.distance(o) - r * r);
+        }
+        cout << res << endl;
+    }
+}
+
+signed main() {
+    GKD;
+    cout << fixed << setprecision(8);
+    auto T = 1;
+    cin >> T;
+    while (T--) genshin_start();
+    return 0;
+}
\ No newline at end of file
Index: WeeklyContest/Team Weekly Contest 2023-12-2/I.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/WeeklyContest/Team Weekly Contest 2023-12-2/I.cpp b/WeeklyContest/Team Weekly Contest 2023-12-2/I.cpp
new file mode 100644
--- /dev/null	(date 1702715830082)
+++ b/WeeklyContest/Team Weekly Contest 2023-12-2/I.cpp	(date 1702715830082)
@@ -0,0 +1,173 @@
+/*
+
+  _______  _______ .__   __.      _______. __    __   __  .__   __.     __  .___  ___. .______      ___       ______ .___________.
+ /  _____||   ____||  \ |  |     /       ||  |  |  | |  | |  \ |  |    |  | |   \/   | |   _  \    /   \     /      ||           |
+|  |  __  |  |__   |   \|  |    |   (----`|  |__|  | |  | |   \|  |    |  | |  \  /  | |  |_)  |  /  ^  \   |  ,----'`---|  |----`
+|  | |_ | |   __|  |  . `  |     \   \    |   __   | |  | |  . `  |    |  | |  |\/|  | |   ___/  /  /_\  \  |  |         |  |
+|  |__| | |  |____ |  |\   | .----)   |   |  |  |  | |  | |  |\   |    |  | |  |  |  | |  |     /  _____  \ |  `----.    |  |
+ \______| |_______||__| \__| |_______/    |__|  |__| |__| |__| \__|    |__| |__|  |__| | _|    /__/     \__\ \______|    |__|
+ 
+□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□□□■■■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■■■■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■■■■■□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□□□□□□□□□■■■□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□■■□□□□□□□□□■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□□□□□□□□■■■■□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□■□□□□□□□□□■■□□□□□□□□■■■■□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□■■□□□□□■■■□□□□□□□■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□■■□□□□□□□□■■□□□□□■■■■■■■■□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□■■■□□□□■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□■■■□□□□□□□■■■■■■■■■■■■■■□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□■■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■□■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□■■■■■■■■■■■■■■■■■□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■■■■■■■□■■■■■■■■■■■■■■■■□□□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□■■■■■■■■□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■■■■■■■■■□□□■■■■■■■■■□■■□□□□□□□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■□□□□□■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■□□□□■■■■□□□■■■□□□□□□□■■□□□□□□□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■□□□□□■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□■■■■□□□□■■■□□□□□□□■■□□□□□□□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■□□□□□■■■□□□□□□□■■■■■■■■□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□■■□□□□□□□■■□□□□□□□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■■■■■■■■■■■■■■■■□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□■■□□□□□□□■■■■■■■■□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□■■□■■■■■■■■■■■■■■■□■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■■■■■■■■□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■□□□□□□■■■■■■■■■■■■■■■■□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■□□□□■■■■■■■■■■■□□□□□□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■■■□□□■■■□□□□□□■■□□□□□□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■□□□□□□□□□□□□■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■□■■■■■□□■■■□□□□□□■■□□□□□□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■□□□■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□■■■□□■■■■□□■■■□□□□□□■■□□□□□□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□■■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□■■■□□□■■■□□■■■□□□□□□■■□□□□□□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□■■■□□□□□■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□■■■□□□□■■□□■■■□□□□□□■■□□□■■■□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□■■■□□□□□□■■■■■■■□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□■■■□□□□□■□□■■■□■■■■■■■■■■■■■■■■■□□□□□□□□□□□□
+□□□□□□□□□□□□■■■□□□□□□□■■□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□■■■□□□□□□□■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□
+□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□■■■□□□□□□□■■■■■■■■■■■■■□□□□□□■■□□□□□□□□□□□□□
+□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□■■■□□□□□□□■■■■□□□□□□■■□□□□□□□■■□□□□□□□□□□□□□
+□□□□□□□□□□□■■■□□□□□□□□■■□□□□□□□■■■□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□■■■□□□□□□□□■■□□□□□□□■■□□□□□□□■■□□□□□□□□□□□□□
+□□□□□□□□□□□■■■□□□□□□□□■■■□□□□□□■■□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□□□■■■□□□□□□□□■■□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□■■■□□□□□□□□□■■■□□□□□□■■□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□■■■□□□□□□□□■■■■■□□□□□■■□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□■■■□□□□□□□■■■■■□□□□□□■■□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□■■■□□□□□□□■■■■■□□□□□□□■■□□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□■■■□□□□□□□■■■■□□□□□□□□■■□□□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□■■■□□□□□□□■■■■□□□□□□□□□■■□□□□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□■■■□□□□□□□■■■□□□□□□□□□□□■■□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□■■■□□□□□□■■■□□□□□■■□□□□□■■□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□■■■□□□□□□■■■□□□□□□■■■■□□□■■□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□■■□□□□□□■■■□□□□□□□□■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□■■■□□□□□□■■□□□□□□□□□□■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□■■□□□□□□□□□□□□□□□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□
+
+  ______                 _    _  __      ___ _
+ |  ____|               | |  (_) \ \    / (_) |
+ | |__ _   _ _   _ _   _| | ___   \ \  / / _| | __ _
+ |  __| | | | | | | | | | |/ / |   \ \/ / | | |/ _` |
+ | |  | |_| | |_| | |_| |   <| |    \  /  | | | (_| |
+ |_|   \__,_|\__, |\__,_|_|\_\_|     \/   |_|_|\__,_|
+              __/ |
+             |___/
+
+*/
+
+#define GKD std::cin.tie(nullptr)->std::ios::sync_with_stdio(false)
+#define clr(a, b) memset(a, b, sizeof(a))
+#define cpy(a, b) memcpy(a, b, sizeof(a));
+
+#include <bits/stdc++.h>
+
+#define dbg(x...) \
+    do { \
+        std::cout << #x << " -> "; \
+        err(x); \
+    } while (0)
+
+void err() {
+    std::cout << std::endl;
+}
+
+template<class T, class... Ts>
+void err(T arg, Ts &... args) {
+    std::cout << arg << ' ';
+    err(args...);
+}
+
+using namespace std;
+using ll = long long;
+using ull = unsigned long long;
+template<typename T, typename K>
+using umap = unordered_map<T, K>;
+template<typename T>
+using uset = unordered_set<T>;
+const double pi = acos(-1);
+const int INF = 0x3f3f3f3f;
+ll mod = 0;
+
+inline ll qpow(ll _a, ll _n, ll _mod = mod) {
+    ll ans = 1;
+    while (_n) {
+        if (_n & 1) ans *= _a;
+        _n >>= 1;
+        _a *= _a;
+        if (_mod > 0) {
+            ans %= _mod;
+            _a %= _mod;
+        }
+    }
+    return ans;
+}
+
+constexpr int N = 1e7 + 100;
+int minp[N];
+vector<int> primes;
+bool st[N];
+
+void get_primes(int n) {
+    for (int i = 2; i <= n; i++) {
+        if (!st[i]) minp[i] = i, primes.emplace_back(i);
+        for (int j = 0; primes[j] * i <= n; j++) {
+            int t = primes[j] * i;
+            st[t] = true;
+            minp[t] = primes[j];
+            if (i % primes[j] == 0) break;
+        }
+    }
+}
+
+std::random_device rd;
+std::default_random_engine eng(rd());
+std::uniform_int_distribution<ll> ranint(1, 1e18);
+
+//玩原神导致的
+const int maxn = 109;
+unordered_map<ll,map<ll,ll> > dp[maxn];
+void solve(){
+    int n;
+    cin >> n;
+    dp[0][0][0] = 0;
+    int a,b,c;
+    for(int i = 1;i <= n;i ++){
+        cin >> a >> b >> c;
+        for(auto [A,t]:dp[i - 1]){
+            for(auto [D,r] : t ){
+                dp[i][A + D][D] = max(dp[i][A + D][D],dp[i - 1][A][D] + A + D + a);
+                dp[i][A + D + c][D] = max(dp[i][A + D + c][D],dp[i - 1][A][D]);
+                dp[i][A + D][D + b] = max(dp[i][A + D][D + b],dp[i - 1][A][D]);
+            }
+        }
+    }
+    ll ans = 0;
+    for(auto [A,t]:dp[n]){
+        for(auto [D,r] : t){
+            ans = max(ans,dp[n][A][D]);
+        }
+    }
+    cout << ans << endl;
+}
+signed main(){
+    ios::sync_with_stdio(0);
+    cin.tie(0);
+    int t = 1;
+	cin >> t;
+    while(t --){
+        solve();
+    }
+    return 0;
+}
Index: test/D.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test/D.cpp b/test/D.cpp
new file mode 100644
--- /dev/null	(date 1702716193694)
+++ b/test/D.cpp	(date 1702716193694)
@@ -0,0 +1,159 @@
+/*
+
+  _______  _______ .__   __.      _______. __    __   __  .__   __.     __  .___  ___. .______      ___       ______ .___________.
+ /  _____||   ____||  \ |  |     /       ||  |  |  | |  | |  \ |  |    |  | |   \/   | |   _  \    /   \     /      ||           |
+|  |  __  |  |__   |   \|  |    |   (----`|  |__|  | |  | |   \|  |    |  | |  \  /  | |  |_)  |  /  ^  \   |  ,----'`---|  |----`
+|  | |_ | |   __|  |  . `  |     \   \    |   __   | |  | |  . `  |    |  | |  |\/|  | |   ___/  /  /_\  \  |  |         |  |
+|  |__| | |  |____ |  |\   | .----)   |   |  |  |  | |  | |  |\   |    |  | |  |  |  | |  |     /  _____  \ |  `----.    |  |
+ \______| |_______||__| \__| |_______/    |__|  |__| |__| |__| \__|    |__| |__|  |__| | _|    /__/     \__\ \______|    |__|
+
+□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□□□■■■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■■■■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■■■■■□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□□□□□□□□□■■■□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□■■□□□□□□□□□■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□□□□□□□□■■■■□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□■□□□□□□□□□■■□□□□□□□□■■■■□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□■■□□□□□■■■□□□□□□□■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□■■□□□□□□□□■■□□□□□■■■■■■■■□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□■■■□□□□■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□■■■□□□□□□□■■■■■■■■■■■■■■□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□■■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■□■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□■■■■■■■■■■■■■■■■■□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■■■■■■■□■■■■■■■■■■■■■■■■□□□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■■□□□■■■■■■■■□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■■■■■■■■■□□□■■■■■■■■■□■■□□□□□□□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■□□□□□■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■□□□□■■■■□□□■■■□□□□□□□■■□□□□□□□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■□□□□□■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□■■■■□□□□■■■□□□□□□□■■□□□□□□□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□□■■□□□□□■■■□□□□□□□■■■■■■■■□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□■■□□□□□□□■■□□□□□□□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■■■■■■■■■■■■■■■■□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□■■□□□□□□□■■■■■■■■□□■■■□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□■■□■■■■■■■■■■■■■■■□■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■■■■■■■■□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■□□□□□□■■■■■■■■■■■■■■■■□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■□□□□■■■■■■■■■■■□□□□□□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■■■□□□■■■□□□□□□■■□□□□□□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■□□□□□□□□□□□□■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■□■■■■■□□■■■□□□□□□■■□□□□□□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□□■■■□□□■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□■■■□□■■■■□□■■■□□□□□□■■□□□□□□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□□■■■□□□□■■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□■■■□□□■■■□□■■■□□□□□□■■□□□□□□□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□■■■□□□□□■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□■■■□□□□■■□□■■■□□□□□□■■□□□■■■□■■■□□□□□□□□□□□□
+□□□□□□□□□□□□■■■□□□□□□■■■■■■■□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□■■■□□□□□■□□■■■□■■■■■■■■■■■■■■■■■□□□□□□□□□□□□
+□□□□□□□□□□□□■■■□□□□□□□■■□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□■■■□□□□□□□■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□
+□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□■■■□□□□□□□■■■■■■■■■■■■■□□□□□□■■□□□□□□□□□□□□□
+□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□■■■□□□□□□□■■■■□□□□□□■■□□□□□□□■■□□□□□□□□□□□□□
+□□□□□□□□□□□■■■□□□□□□□□■■□□□□□□□■■■□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□■■■□□□□□□□□■■□□□□□□□■■□□□□□□□■■□□□□□□□□□□□□□
+□□□□□□□□□□□■■■□□□□□□□□■■■□□□□□□■■□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□□□■■■□□□□□□□□■■□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□■■■□□□□□□□□□■■■□□□□□□■■□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□■■■□□□□□□□□■■■■■□□□□□■■□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□■■■□□□□□□□■■■■■□□□□□□■■□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□■■■□□□□□□□■■■■■□□□□□□□■■□□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□■■■□□□□□□□■■■■□□□□□□□□■■□□□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□■■■□□□□□□□■■■■□□□□□□□□□■■□□□□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□■■■□□□□□□□■■■□□□□□□□□□□□■■□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□■■■□□□□□□■■■□□□□□■■□□□□□■■□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□■■■□□□□□□■■■□□□□□□■■■■□□□■■□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□■■□□□□□□■■■□□□□□□□□■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□■■■□□□□□□■■□□□□□□□□□□■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□■■□□□□□□□□□□□□□□□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□
+□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□
+
+  ______                 _    _  __      ___ _
+ |  ____|               | |  (_) \ \    / (_) |
+ | |__ _   _ _   _ _   _| | ___   \ \  / / _| | __ _
+ |  __| | | | | | | | | | |/ / |   \ \/ / | | |/ _` |
+ | |  | |_| | |_| | |_| |   <| |    \  /  | | | (_| |
+ |_|   \__,_|\__, |\__,_|_|\_\_|     \/   |_|_|\__,_|
+              __/ |
+             |___/
+
+*/
+
+#define GKD std::cin.tie(nullptr)->std::ios::sync_with_stdio(false)
+#define clr(a, b) memset(a, b, sizeof(a))
+
+#include <bits/stdc++.h>
+
+#define dbg(x...) \
+    do { \
+        std::cout << #x << " -> "; \
+        err(x); \
+    } while (0)
+
+void err() {
+    std::cout << std::endl;
+}
+
+template<class T, class... Ts>
+void err(T arg, Ts &... args) {
+    std::cout << arg << ' ';
+    err(args...);
+}
+
+using namespace std;
+using ll = long long;
+using ull = unsigned long long;
+template<typename T, typename K>
+using umap = unordered_map<T, K>;
+template<typename T>
+using uset = unordered_set<T>;
+const double pi = acos(-1);
+const int INF = 0x3f3f3f3f;
+ll mod = 0;
+
+inline ll qpow(ll _a, ll _n, ll _mod = mod) {
+    ll ans = 1;
+    while (_n) {
+        if (_n & 1) ans *= _a;
+        _n >>= 1;
+        _a *= _a;
+        if (_mod > 0) {
+            ans %= _mod;
+            _a %= _mod;
+        }
+    }
+    return ans;
+}
+
+constexpr int N = 1e7 + 100;
+int minp[N];
+vector<int> primes;
+bool st[N];
+
+void get_primes(int n) {
+    for (int i = 2; i <= n; i++) {
+        if (!st[i]) minp[i] = i, primes.emplace_back(i);
+        for (int j = 0; primes[j] * i <= n; j++) {
+            int t = primes[j] * i;
+            st[t] = true;
+            minp[t] = primes[j];
+            if (i % primes[j] == 0) break;
+        }
+    }
+}
+
+std::random_device rd;
+std::default_random_engine eng(rd());
+std::uniform_int_distribution<ll> ranint(1, 1e18);
+
+//玩原神导致的
+void genshin_start(int testCase) {
+    cout << "Case #" << testCase << ": ";
+    ll x, y;
+    cin >> x >> y;
+    bitset<64> a(x), b(y);
+    if (a.count() != b.count()) {
+        cout << -1 << '\n';
+        return;
+    }
+
+}
+
+signed main() {
+    GKD;
+    int T = 1;
+    cin >> T;
+    for (int i = 1; i <= T; i++) {
+        genshin_start(i);
+    }
+    return 0;
+}
+
Index: 板子/计算几何.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nconst double PI = acos(-1.0);\r\nconstexpr double eps = 1e-7;\r\n\r\nconstexpr int sgn(double x) {\r\n    if (fabs(x) < eps) {\r\n        return 0;\r\n    }\r\n    if (x < 0) {\r\n        return -1;\r\n    } else {\r\n        return 1;\r\n    }\r\n}\r\n\r\ndouble radian(double degree) {\r\n    return degree * PI / 180.0;\r\n}\r\n\r\nnamespace Dimension2 {\r\n\r\n    class Point {\r\n    public:\r\n        typedef Point Vector;\r\n        double x, y;\r\n\r\n        constexpr Point() : x(), y() {};\r\n\r\n        constexpr Point(double x, double y) : x(x), y(y) {};\r\n\r\n        //加\r\n        constexpr Vector operator+(const Vector &p) const {\r\n            return {x + p.x, y + p.y};\r\n        }\r\n\r\n        //减\r\n        constexpr Vector operator-(const Vector &p) const {\r\n            return {x - p.x, y - p.y};\r\n        }\r\n\r\n        //叉积\r\n        constexpr double operator^(const Vector &p) const {\r\n            return x * p.y - y * p.x;\r\n        }\r\n\r\n        //点积\r\n        constexpr double operator*(const Vector &p) const {\r\n            return x * p.x + y * p.y;\r\n        }\r\n\r\n        //数乘\r\n        constexpr Vector operator*(double b) const {\r\n            return {x * b, y * b};\r\n        }\r\n\r\n        constexpr Vector operator/(double b) const {\r\n            return {x / b, y / b};\r\n        }\r\n\r\n        //等于\r\n        constexpr bool operator==(const Point &p) const {\r\n            return sgn(x - p.x) == 0 && sgn(y - p.y) == 0;\r\n        }\r\n\r\n        //绕着点p逆时针旋转弧度b\r\n        constexpr Point &rotate(double b, const Point &p = {0, 0}) {\r\n            double newX = (x - p.x) * cos(b) - (y - p.y) * sin(b) + p.x;\r\n            double newY = (x - p.x) * cos(b) + (y - p.y) * cos(b) + p.y;\r\n            x = newX;\r\n            y = newY;\r\n            return *this;\r\n        }\r\n\r\n        //模\r\n        constexpr double norm() const {\r\n            return sqrt(*this * *this);\r\n        }\r\n\r\n        //点距\r\n        constexpr double distance(Point p) const {\r\n            return (*this - p).norm();\r\n        }\r\n\r\n\r\n    };\r\n\r\n    using Vector = Point;\r\n\r\n    class Line {\r\n    public:\r\n        typedef Line Seg;\r\n        Point a, b;\r\n\r\n        constexpr Line() : a(), b() {}\r\n\r\n        constexpr Line(Point a, Point b) : a(a), b(b) {}\r\n\r\n        //两直线相交求交点\r\n        //第一个值为0表示直线重合，为1表示平行,为2是相交\r\n        //只有第一个值为2时，交点才有意义\r\n        constexpr pair<int, Point> operator&(const Line &l) const {\r\n            Point res;\r\n            if (sgn((a - b) ^ (l.a - l.b)) == 0) {\r\n                if (sgn((a - l.b) ^ (l.a - l.b)) == 0) {\r\n                    return {0, res}; //重合\r\n                } else {\r\n                    return {1, res}; //平行\r\n                }\r\n            }\r\n            double t = ((a - l.a) ^ (l.a - l.b)) / ((a - b) ^ (l.a - l.b));\r\n            res.x += (b.x - a.x) * t;\r\n            res.y += (b.y - a.y) * t;\r\n            return {2, res};\r\n        }\r\n\r\n        //判断点在线段上\r\n        constexpr bool pointOnSeg(const Point &p) const {\r\n            return sgn((a - p) ^ (b - p)) == 0 &&\r\n                   sgn((p.x - a.x) * (p.x - b.x)) <= 0 &&\r\n                   sgn((p.y - a.y) * (p.y - b.y)) <= 0;\r\n        }\r\n\r\n        //判断线段是否相交\r\n        //返回1表示相交,0表示不相交\r\n        constexpr bool seg_inter_seg(const Seg &l) const {\r\n            auto [res, intersectionPoint] = *this & l;\r\n            return res == 2 && pointOnSeg(intersectionPoint) && l.pointOnSeg(intersectionPoint);\r\n        }\r\n\r\n        //判断直线与线段l是否相交\r\n        //返回1表示相交,0表示不相交\r\n        constexpr bool line_inter_seg(const Seg &l) const {\r\n            auto [res, intersectionPoint] = *this & l;\r\n            return res == 2 && l.pointOnSeg(intersectionPoint);\r\n        }\r\n\r\n        //求点到直线的距离\r\n        //返回点到直线上最近的点，垂足\r\n        constexpr Point pointToLine(const Point &p) const {\r\n            Point res;\r\n            double t = ((p - a) * (b - a)) / ((b - a) * (b - a));\r\n            res.x = a.x + (b.x - a.x) * t;\r\n            res.y = a.y + (b.y - a.y) * t;\r\n            return res;\r\n        }\r\n\r\n        constexpr double distance(const Point &p) const {\r\n            return p.distance(pointToLine(p));\r\n        }\r\n\r\n        constexpr double distance(const Line &l) const {\r\n            auto [result, intersectionPoint] = *this & l;\r\n            if (result != 1) {\r\n                return 0;\r\n            } else {\r\n                return distance(l.a);\r\n            }\r\n        }\r\n\r\n        //判断点在直线上\r\n        constexpr bool pointOnLine(const Point &p) const {\r\n            return sgn(pointToLine(p).distance(p)) == 0;\r\n        }\r\n\r\n        //求点到线段的距离\r\n        //返回点到线段最近的点\r\n        constexpr Point nearestPointToSeg(const Point &p) const {\r\n            Point res;\r\n            double t = ((p - a) * (b - a)) / ((b - a) * (b - a));\r\n            if (t >= 0 && t <= 1) {\r\n                res.x = a.x + (b.x - a.x) * t;\r\n                res.y = a.y + (b.y - a.y) * t;\r\n            } else {\r\n                if (p.distance(a) < p.distance(b))\r\n                    res = a;\r\n                else\r\n                    res = b;\r\n            }\r\n            return res;\r\n        }\r\n\r\n    };\r\n\r\n    using Seg = Line;\r\n\r\n    //计算多边形面积\r\n    constexpr static double calcArea(const vector<Point> &p) {\r\n        double res = 0;\r\n        for (int i = 0; i < p.size(); i++) {\r\n            res += (p[i] ^ p[(i + 1) % p.size()]) / 2;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    //对点p极角排序，按逆时针排序\r\n    class AngleSort {\r\n    public:\r\n        Point p;\r\n\r\n        AngleSort() : p() {}\r\n\r\n        explicit AngleSort(const Point &p) : p(p) {}\r\n\r\n        bool operator()(const Point &a, const Point &b) const {\r\n            if (a.x >= 0 && b.x < 0)\r\n                return true;\r\n            if (a.x == 0 && b.x == 0)\r\n                return a.y > b.y;\r\n            //向量OA和向量OB的叉积\r\n            double det = (a - p) ^ (b - p);\r\n            if (det < 0)\r\n                return true;\r\n            if (det > 0)\r\n                return false;\r\n            //向量OA和向量OB共线，以距离判断大小\r\n            return a.distance(p) > b.distance(p);\r\n        }\r\n    };\r\n\r\n    //判断点在凸多边形内\r\n    //要求\r\n    // 点形成一个凸包，而且按逆时针排序\r\n    // 如果是顺时针把里面的 <0 改为 >0\r\n    // 点的编号:0~n-1\r\n    //返回值：\r\n    // -1:点在凸多边形外\r\n    // 0:点在凸多边形边界上\r\n    // 1:点在凸多边形内\r\n    constexpr static int pointInConvexPoly(const Point &a, const vector<Point> &p) {\r\n        int n = p.size();\r\n        for (int i = 0; i < n; i++) {\r\n            if (sgn((p[i] - a) ^ (p[(i + 1) % n] - a)) < 0)\r\n                return -1;\r\n            else if (Seg(p[i], p[(i + 1) % n]).pointOnSeg(a))\r\n                return 0;\r\n        }\r\n        return 1;\r\n    }\r\n\r\n    //判断点是否在凸包内\r\n    constexpr static bool pointInConvex(const Point &a, const vector<Point> &p) {\r\n        int l = 1, r = p.size() - 2;\r\n        while (l <= r) {\r\n            int mid = (l + r) >> 1;\r\n            double a1 = (p[mid] - p[0]) ^ (a - p[0]);\r\n            double a2 = (p[mid + 1] - p[0]) ^ (a - p[0]);\r\n            if (a1 >= 0 && a2 <= 0) {\r\n                if (((p[mid + 1] - p[mid]) ^ (a - p[mid])) >= 0)\r\n                    return true;\r\n                return false;\r\n            } else if (a1 < 0)\r\n                r = mid - 1;\r\n            else\r\n                l = mid + 1;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    //判断点在任意多边形内\r\n    //射线法，poly[]的顶点数要大于等于3,点的编号0~n-1\r\n    //返回值\r\n    // -1:点在凸多边形外\r\n    // 0:点在凸多边形边界上\r\n    // 1:点在凸多边形内\r\n    static int PointInPoly(const Point &p, const vector<Point> &poly) {\r\n        int n = poly.size();\r\n        int cnt;\r\n        Line ray, side;\r\n        cnt = 0;\r\n        ray.a = p;\r\n        ray.b.y = p.y;\r\n        ray.b.x = -100000000000.0; //-INF,注意取值防止越界\r\n        for (int i = 0; i < n; i++) {\r\n            side.a = poly[i];\r\n            side.b = poly[(i + 1) % n];\r\n\r\n            if (side.pointOnSeg(p))\r\n                return 0;\r\n\r\n            //如果平行轴则不考虑\r\n            if (sgn(side.a.y - side.b.y) == 0) {\r\n                continue;\r\n            }\r\n\r\n            if (ray.pointOnSeg(side.a)) {\r\n                if (sgn(side.a.y - side.b.y) > 0) {\r\n                    cnt++;\r\n                }\r\n            } else if (ray.pointOnSeg(side.b)) {\r\n                if (sgn(side.b.y - side.a.y) > 0) {\r\n                    cnt++;\r\n                }\r\n            } else if (ray.seg_inter_seg(side)) {\r\n                cnt++;\r\n            }\r\n        }\r\n        if (cnt % 2 == 1)\r\n            return 1;\r\n        else\r\n            return -1;\r\n    }\r\n\r\n    //判断凸多边形\r\n    //允许共线边\r\n    //点可以是顺时针给出也可以是逆时针给出\r\n    constexpr static bool isConvex(const vector<Point> &poly) {\r\n        int n = poly.size();\r\n        bitset<3> s;\r\n        for (int i = 0; i < n; i++) {\r\n            s[sgn((poly[(i + 1) % n] - poly[i]) ^ (poly[(i + 2) % n] - poly[i])) + 1] = true;\r\n            if (s[0] && s[2])\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //判断凸包是否相离\r\n    //凸包a：n个点,凸包b：m个点\r\n    // 凸包上的点不能出现在另一个凸包内\r\n    // 凸包上的线段两两不能相交\r\n    static bool isConvexHullSeparate(const vector<Point> &a, const vector<Point> &b) {\r\n        int n = a.size(), m = b.size();\r\n        for (int i = 0; i < n; i++)\r\n            if (PointInPoly(a[i], b) != -1)\r\n                return false;\r\n\r\n        for (int i = 0; i < m; i++)\r\n            if (PointInPoly(b[i], a) != -1)\r\n                return false;\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < m; j++) {\r\n                Line l1 = Line(a[i], a[(i + 1) % n]);\r\n                Line l2 = Line(b[j], b[(j + 1) % m]);\r\n                if (l1.seg_inter_seg(l2))\r\n                    return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\nnamespace Dimension3 {\r\n    class Point {\r\n    public:\r\n        typedef Point Vector;\r\n        double x, y, z;\r\n\r\n        constexpr Point() : x(), y(), z() {}\r\n\r\n        constexpr Point(double x, double y, double z) : x(x), y(y), z(z) {}\r\n\r\n        //加\r\n        constexpr Vector operator+(const Vector &v) const {\r\n            return {x + v.x, y + v.y, z + v.z};\r\n        }\r\n\r\n        //减\r\n        constexpr Vector operator-(const Vector &v) const {\r\n            return {x - v.x, y - v.y, z - v.z};\r\n        }\r\n\r\n        //点积\r\n        constexpr double operator*(const Vector &v) const {\r\n            return x * v.x + y * v.y + z * v.z;\r\n        }\r\n\r\n        //叉积\r\n        constexpr Vector operator^(const Vector &v) const {\r\n            return {y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x};\r\n        }\r\n\r\n        //数乘\r\n        constexpr Vector operator*(double b) const {\r\n            return {x * b, y * b, z * b};\r\n        }\r\n\r\n        constexpr Vector operator/(double b) const {\r\n            return {x / b, y / b, z / b};\r\n        }\r\n\r\n        //等于\r\n        constexpr bool operator==(const Vector &v) const {\r\n            return sgn(x - v.x) == 0 && sgn(y - v.y) && sgn(z - v.z);\r\n        }\r\n\r\n        //绕点p逆时针旋转弧度b\r\n        constexpr Point &rotate(double radian, const Point &p = {0, 0, 0}) {\r\n            // 将点平移到原点\r\n            double translatedX = x - p.x;\r\n            double translatedY = y - p.y;\r\n            double translatedZ = z - p.z;\r\n\r\n            // 使用旋转矩阵进行三维旋转\r\n            double cosTheta = cos(radian);\r\n            double sinTheta = sin(radian);\r\n\r\n            double newX = translatedX * cosTheta - translatedY * sinTheta;\r\n            double newY = translatedX * sinTheta + translatedY * cosTheta;\r\n            double newZ = translatedZ;\r\n\r\n            // 将点平移到原始位置\r\n            x = newX + p.x;\r\n            y = newY + p.y;\r\n            z = newZ + p.z;\r\n\r\n            return *this;\r\n        }\r\n\r\n        //模\r\n        constexpr double norm() const {\r\n            return sqrt(*this * *this);\r\n        }\r\n\r\n        //点距\r\n        constexpr double distance(const Point &p) const {\r\n            return (*this - p).norm();\r\n        }\r\n\r\n    };\r\n\r\n    using Vector = Point;\r\n\r\n    class Line {\r\n    public:\r\n        Point a, b;\r\n        typedef Line Seg;\r\n\r\n        constexpr Line() : a(), b() {}\r\n\r\n        constexpr Line(const Point &a, const Point &b) : a(a), b(b) {}\r\n\r\n        //线段长度\r\n        constexpr double length() const {\r\n            return (b - a).norm();\r\n        }\r\n\r\n        //求点到直线的距离\r\n        //返回点到直线上最近的点，垂足\r\n        constexpr Point pointToLine(const Point &p) const {\r\n            Point direction = b - a;\r\n            Point vector = p - a;\r\n\r\n            // 使用向量的投影计算垂足的位置\r\n            double t = (vector * direction) / direction.norm();\r\n            return a + direction * (t / direction.norm());\r\n        }\r\n\r\n        constexpr double distance(const Point &p) const {\r\n            return p.distance(pointToLine(p));\r\n        }\r\n\r\n        constexpr double distance(const Line &l) const {\r\n            auto [result, intersectionPoint] = *this & l;\r\n            if (result == 1) {\r\n                return distance(l.a);\r\n            } else if (result == 3) {\r\n                return (a - l.a) * ((l.a - l.b) ^ (a - b)) / ((l.a - l.b) ^ (a - b)).norm();\r\n            } else {\r\n                return 0;\r\n            }\r\n        }\r\n\r\n        //判断点在直线上\r\n        constexpr bool pointOnLine(const Point &p) const {\r\n            return sgn(distance(p)) == 0;\r\n        }\r\n\r\n        //两直线相交求交点\r\n        //第一个值为0表示直线重合，为1表示平行,为2是相交，为3是相离\r\n        //只有第一个值为2时，交点才有意义\r\n        constexpr std::pair<int, Point> operator&(const Line &l) const {\r\n            Point direction1 = b - a;\r\n            Point direction2 = l.b - l.a;\r\n            // 判断两直线是否平行\r\n            Point crossProduct = direction1 ^ direction2;\r\n            if (sgn(crossProduct.norm()) == 0) {\r\n                // 平行或重合\r\n                if (pointOnLine(l.a) && pointOnLine(l.b)) {\r\n                    // 重合\r\n                    return {0, Point()};\r\n                } else {\r\n                    // 平行\r\n                    return {1, Point()};\r\n                }\r\n            }\r\n\r\n            // 计算参数 t1 和 t2，使得两直线上的点满足参数方程\r\n            double t1 = ((l.a - a) ^ direction2).norm() / crossProduct.norm();\r\n            double t2 = ((a - l.a) ^ direction1).norm() / crossProduct.norm();\r\n            // 计算交点\r\n            Point intersectionPoint = a + direction1 * t1;\r\n            if (!pointOnLine(intersectionPoint) || !l.pointOnLine(intersectionPoint)) {\r\n                return {3, Point()};\r\n            }\r\n            return {2, intersectionPoint};\r\n        }\r\n\r\n        // 判断点p是否在线段上\r\n        constexpr bool pointOnSeg(const Point &p) const {\r\n\r\n            // 判断点到线段两端点的投影是否在线段上，且点到线段两端点的距离之和等于线段的长度\r\n            return pointOnLine(p) && p.x >= min(a.x, b.x) && p.x <= max(a.x, b.x) && p.y >= min(a.y, b.y) &&\r\n                   p.y <= max(a.y, b.y) && p.z >= min(a.z, b.z) && p.z <= max(a.z, b.z);\r\n        }\r\n\r\n        // 判断线段是否相交\r\n        constexpr bool seg_inter_seg(const Seg &l) const {\r\n            auto [result, intersectionPoint] = *this & l;\r\n\r\n            if (result == 2) {\r\n                // 两线段相交，再判断交点是否在两线段上\r\n                return l.pointOnSeg(intersectionPoint) && pointOnSeg(intersectionPoint);\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        //判断直线与线段l是否相交\r\n        constexpr bool line_inter_seg(const Seg &l) const {\r\n            auto [result, intersectionPoint] = *this & l;\r\n\r\n            if (result == 2) {\r\n                // 两线段相交，再判断交点是否在线段上\r\n                return l.pointOnSeg(intersectionPoint);\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        // 求点到线段的距离，返回点到线段最近的点\r\n        constexpr Point nearestPointToSeg(const Point &p) const {\r\n            Point vectorAP = p - a;\r\n            Point vectorAB = b - a;\r\n\r\n            // 计算点到线段的投影位置\r\n            double t = (vectorAP * vectorAB) / vectorAB.norm();\r\n\r\n            // 如果投影位置小于等于0，则最近的点是线段的起点a\r\n            if (sgn(t) <= 0) {\r\n                return a;\r\n            }\r\n\r\n            // 如果投影位置大于等于线段长度，则最近的点是线段的终点b\r\n            if (sgn(t - vectorAB.norm()) >= 0) {\r\n                return b;\r\n            }\r\n\r\n            // 否则，最近的点是线段上的投影点\r\n            return a + vectorAB * (t / vectorAB.norm());\r\n        }\r\n    };\r\n\r\n    class Plane {\r\n    public:\r\n        Point a, b, c;\r\n\r\n        // 无参构造函数\r\n        constexpr Plane() : a(), b(), c() {}\r\n\r\n        // 有参构造函数\r\n        constexpr Plane(const Point &a, const Point &b, const Point &c) : a(a), b(b), c(c) {}\r\n\r\n        // 面到点的距离\r\n        constexpr double distance(const Point &p) const {\r\n            Point normal = (b - a) ^ (c - a);\r\n            double d = -normal.x * a.x - normal.y * a.y - normal.z * a.z;\r\n            return abs(normal.x * p.x + normal.y * p.y + normal.z * p.z + d) / normal.norm();\r\n        }\r\n\r\n        // 面到线的距离\r\n        constexpr double distance(const Line &l) const {\r\n            auto [res, intersectionPoint] = intersectWithLine(l);\r\n            if (res != 0) {\r\n                return 0;\r\n            } else {\r\n                return distance(l.a);\r\n            }\r\n        }\r\n\r\n        // 面到面的距离\r\n        constexpr double distance(const Plane &p) const {\r\n            auto [res, intersectionPoint] = intersectWithPlane(p);\r\n            if (res != 0) {\r\n                return 0;\r\n            } else {\r\n                return distance(p.a);\r\n            }\r\n        }\r\n\r\n        // 面和线的交点\r\n        constexpr pair<int, Point> intersectWithLine(const Line &line) const {\r\n            Point normal = (b - a) ^ (c - a);\r\n\r\n            // 如果线和面平行，返回空点\r\n            if (sgn((normal * (line.b - line.a)) == 0)) {\r\n                return {0, Point()};\r\n            }\r\n\r\n            // 计算交点\r\n            double t = -((normal.x * (line.a.x - a.x) + normal.y * (line.a.y - a.y) + normal.z * (line.a.z - a.z)) /\r\n                         (normal * (line.b - line.a)));\r\n            return {1, line.a + (line.b - line.a) * t};\r\n        }\r\n\r\n        // 面和面的交线，0为不存在，1为存在\r\n        constexpr std::pair<int, Line> intersectWithPlane(const Plane &other) const {\r\n            Point normal1 = (b - a) ^ (c - a);\r\n            Point normal2 = (other.b - other.a) ^ (other.c - other.a);\r\n            Point direction = normal1 ^ (normal2);\r\n\r\n            // 如果两平面平行，返回空线段\r\n            if (sgn(direction.norm()) == 0) {\r\n                return {0, Line()};\r\n            }\r\n\r\n            // 选择交线上的一点\r\n            Point pointOnLine = a;\r\n\r\n            // 计算交线的方向\r\n            Point lineDirection = normal1 ^ (direction);\r\n\r\n            // 计算交线的终点\r\n            Point endPoint = pointOnLine + lineDirection;\r\n\r\n            return {1, Line(pointOnLine, endPoint)};\r\n        }\r\n\r\n    };\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/板子/计算几何.cpp b/板子/计算几何.cpp
--- a/板子/计算几何.cpp	(revision 673774b3884bb10c2bbb8111491f72cf2146aafb)
+++ b/板子/计算几何.cpp	(date 1702715830090)
@@ -6,7 +6,7 @@
 constexpr double eps = 1e-7;
 
 constexpr int sgn(double x) {
-    if (fabs(x) < eps) {
+    if (abs(x) < eps) {
         return 0;
     }
     if (x < 0) {
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># FOR-ICPC\r\n## 比赛记录\r\n### 2023年4月\r\n#### 2023.4.1<br>第二十届浙大城市学院程序设计竞赛\r\n11th\r\n#### 2023.4.8<br>蓝桥杯\r\n省B 一等奖\r\n#### 2023.4.15<br>The 20th Zhejiang Provincial Collegiate Programming Contest\r\n铁 128th\r\n#### 2023.4.22<br>团队程序设计天梯赛\r\n高校一等奖 团队二等奖 个人三等奖177分\r\n### 2023年6月\r\n#### 2023.6.10<br>蓝桥杯\r\n国B 二等奖
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
--- a/README.md	(revision 673774b3884bb10c2bbb8111491f72cf2146aafb)
+++ b/README.md	(date 1702367683076)
@@ -1,14 +1,27 @@
 # FOR-ICPC
+
 ## 比赛记录
+
 ### 2023年4月
+
 #### 2023.4.1<br>第二十届浙大城市学院程序设计竞赛
+
 11th
+
 #### 2023.4.8<br>蓝桥杯
+
 省B 一等奖
+
 #### 2023.4.15<br>The 20th Zhejiang Provincial Collegiate Programming Contest
+
 铁 128th
+
 #### 2023.4.22<br>团队程序设计天梯赛
+
 高校一等奖 团队二等奖 个人三等奖177分
+
 ### 2023年6月
+
 #### 2023.6.10<br>蓝桥杯
+
 国B 二等奖
\ No newline at end of file
