/*

  _______  _______ .__   __.      _______. __    __   __  .__   __.     __  .___  ___. .______      ___       ______ .___________.
 /  _____||   ____||  \ |  |     /       ||  |  |  | |  | |  \ |  |    |  | |   \/   | |   _  \    /   \     /      ||           |
|  |  __  |  |__   |   \|  |    |   (----`|  |__|  | |  | |   \|  |    |  | |  \  /  | |  |_)  |  /  ^  \   |  ,----'`---|  |----`
|  | |_ | |   __|  |  . `  |     \   \    |   __   | |  | |  . `  |    |  | |  |\/|  | |   ___/  /  /_\  \  |  |         |  |
|  |__| | |  |____ |  |\   | .----)   |   |  |  |  | |  | |  |\   |    |  | |  |  |  | |  |     /  _____  \ |  `----.    |  |
 \______| |_______||__| \__| |_______/    |__|  |__| |__| |__| \__|    |__| |__|  |__| | _|    /__/     \__\ \______|    |__|
 
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□■■■□□□□□□□■■■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□■■■■■■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□■■■■■■■□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□■■■□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□■■■□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□■■■□□□□□□□□□□□■■■□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□■■□□□□□□□□□■■□□□□□□□□□□□
□□□□□□□□□□□□□□■■■□□□□□□□□□□■■■■□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□■□□□□□□□□□■■□□□□□□□□■■■■□□□□□□□□□□
□□□□□□□□□□□□□□■■■□□□■■□□□□□■■■□□□□□□□■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□■■□□□□□□□□■■□□□□□■■■■■■■■□□□□□□□□□
□□□□□□□□□□□□□□■■■□□□■■■□□□□■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□■■■□□□□□□□■■■■■■■■■■■■■■□□□□□□□□□□
□□□□□□□□□□□□□□■■■□□□■■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■□■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□
□□□□□□□□□□□□□□■■■□□□■■■■■■■■■■■■■■■■■□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■■■■■■■□■■■■■■■■■■■■■■■■□□□□■■■□□□□□□□□□□□
□□□□□□□□□□□□□□■■■□□□■■■■■■■■□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■■■■■■■■■□□□■■■■■■■■■□■■□□□□□□□□■■■□□□□□□□□□□□
□□□□□□□□□□□□□□■■□□□□□■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■□□□□■■■■□□□■■■□□□□□□□■■□□□□□□□□■■■□□□□□□□□□□□
□□□□□□□□□□□□□□■■□□□□□■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□■■■■□□□□■■■□□□□□□□■■□□□□□□□□■■■□□□□□□□□□□□
□□□□□□□□□□□□□□■■□□□□□■■■□□□□□□□■■■■■■■■□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□■■□□□□□□□■■□□□□□□□□■■■□□□□□□□□□□□
□□□□□□□□□□□□□■■■□□□□□■■■■■■■■■■■■■■■■■■□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□■■□□□□□□□■■■■■■■■□□■■■□□□□□□□□□□□
□□□□□□□□□□□□□■■■□□□□□■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□■■□■■■■■■■■■■■■■■■□■■□□□□□□□□□□□□
□□□□□□□□□□□□□■■■□□□□□■■■■■■■■■■□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■□□□□□□■■■■■■■■■■■■■■■■□□■■■□□□□□□□□□□□□
□□□□□□□□□□□□□■■■□□□□□■■■□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■□□□□■■■■■■■■■■■□□□□□□□■■■□□□□□□□□□□□□
□□□□□□□□□□□□□■■■□□□□□■■■□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■■■■■□□□■■■□□□□□□■■□□□□□□□■■■□□□□□□□□□□□□
□□□□□□□□□□□□□■■■□□□□□■■■□□□□□□□□□□□□■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■■■■□■■■■■□□■■■□□□□□□■■□□□□□□□■■■□□□□□□□□□□□□
□□□□□□□□□□□□□■■■□□□□□■■■□□□■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□■■■□□■■■■□□■■■□□□□□□■■□□□□□□□■■■□□□□□□□□□□□□
□□□□□□□□□□□□□■■■□□□□■■■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□■■■□□□■■■□□■■■□□□□□□■■□□□□□□□■■■□□□□□□□□□□□□
□□□□□□□□□□□□■■■□□□□□■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□■■■□□□□■■□□■■■□□□□□□■■□□□■■■□■■■□□□□□□□□□□□□
□□□□□□□□□□□□■■■□□□□□□■■■■■■■□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□■■■□□□□□■□□■■■□■■■■■■■■■■■■■■■■■□□□□□□□□□□□□
□□□□□□□□□□□□■■■□□□□□□□■■□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□■■■□□□□□□□■■■■■■■■■■■■■■■■■■■■■■□□□□□□□□□□□□
□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□■■■□□□□□□□■■■■■■■■■■■■■□□□□□□■■□□□□□□□□□□□□□
□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□■■■□□□□□□□■■■■□□□□□□■■□□□□□□□■■□□□□□□□□□□□□□
□□□□□□□□□□□■■■□□□□□□□□■■□□□□□□□■■■□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□■■■□□□□□□□□■■□□□□□□□■■□□□□□□□■■□□□□□□□□□□□□□
□□□□□□□□□□□■■■□□□□□□□□■■■□□□□□□■■□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□□□■■■□□□□□□□□■■□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□■■■□□□□□□□□□■■■□□□□□□■■□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□■■■□□□□□□□□■■■■■□□□□□■■□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□■■■□□□□□□□■■■■■□□□□□□■■□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□■■■□□□□□□□■■■■■□□□□□□□■■□□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□■■■□□□□□□□■■■■□□□□□□□□■■□□□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□■■■□□□□□□□■■■■□□□□□□□□□■■□□□□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□■■■□□□□□□□■■■□□□□□□□□□□□■■□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□■■■□□□□□□■■■□□□□□■■□□□□□■■□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
□□□□□□■■■□□□□□□■■■□□□□□□■■■■□□□■■□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□□□□□□
□□□□□□■■□□□□□□■■■□□□□□□□□■■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□
□□□□□■■■□□□□□□■■□□□□□□□□□□■■■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□
□□□□□■■□□□□□□□□□□□□□□□□□□□□□■■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■■□□□□□□□□□□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□

  ______                 _    _  __      ___ _
 |  ____|               | |  (_) \ \    / (_) |
 | |__ _   _ _   _ _   _| | ___   \ \  / / _| | __ _
 |  __| | | | | | | | | | |/ / |   \ \/ / | | |/ _` |
 | |  | |_| | |_| | |_| |   <| |    \  /  | | | (_| |
 |_|   \__,_|\__, |\__,_|_|\_\_|     \/   |_|_|\__,_|
              __/ |
             |___/

*/

#define GKD std::cin.tie(nullptr)->std::ios::sync_with_stdio(false)
#define clr(a, b) memset(a, b, sizeof(a))
#define cpy(a, b) memcpy(a, b, sizeof(a));

#include <bits/stdc++.h>

#define dbg(x...) \
    do { \
        std::cout << #x << " -> "; \
        err(x); \
    } while (0)

void err() {
    std::cout << std::endl;
}

template<class T, class... Ts>
void err(T arg, Ts &... args) {
    std::cout << arg << ' ';
    err(args...);
}

using namespace std;
using ll = long long;
using ull = unsigned long long;
template<typename T, typename K>
using umap = unordered_map<T, K>;
template<typename T>
using uset = unordered_set<T>;
const double pi = acos(-1);
const int INF = 0x3f3f3f3f;
const double PI = acos(-1.0);
constexpr double eps = 1e-7;
constexpr int sgn(double x) {
    if (abs(x) < eps) {
        return 0;
    }
    if (x < 0) {
        return -1;
    } else {
        return 1;
    }
}

double radian(double degree) {
    return degree * PI / 180.0;
}

namespace Dimension3 {
    class Point {
    public:
        typedef Point Vector;
        double x, y, z;

        constexpr Point() : x(), y(), z() {}

        constexpr Point(double x, double y, double z) : x(x), y(y), z(z) {}

        //加
        constexpr Vector operator+(const Vector &v) const {
            return {x + v.x, y + v.y, z + v.z};
        }

        //减
        constexpr Vector operator-(const Vector &v) const {
            return {x - v.x, y - v.y, z - v.z};
        }

        //点积
        constexpr double operator*(const Vector &v) const {
            return x * v.x + y * v.y + z * v.z;
        }

        //叉积
        constexpr Vector operator^(const Vector &v) const {
            return {y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x};
        }

        //数乘
        constexpr Vector operator*(double b) const {
            return {x * b, y * b, z * b};
        }

        constexpr Vector operator/(double b) const {
            return {x / b, y / b, z / b};
        }

        //等于
        constexpr bool operator==(const Vector &v) const {
            return sgn(x - v.x) == 0 && sgn(y - v.y) && sgn(z - v.z);
        }

        //绕点p逆时针旋转弧度b
        constexpr Point &rotate(double radian, const Point &p = {0, 0, 0}) {
            // 将点平移到原点
            double translatedX = x - p.x;
            double translatedY = y - p.y;
            double translatedZ = z - p.z;

            // 使用旋转矩阵进行三维旋转
            double cosTheta = cos(radian);
            double sinTheta = sin(radian);

            double newX = translatedX * cosTheta - translatedY * sinTheta;
            double newY = translatedX * sinTheta + translatedY * cosTheta;
            double newZ = translatedZ;

            // 将点平移到原始位置
            x = newX + p.x;
            y = newY + p.y;
            z = newZ + p.z;

            return *this;
        }

        //模
        constexpr double norm() const {
            return sqrt(*this * *this);
        }

        //点距
        constexpr double distance(const Point &p) const {
            return (*this - p).norm();
        }

    };

    using Vector = Point;

    class Line {
    public:
        Point a, b;
        typedef Line Seg;

        constexpr Line() : a(), b() {}

        constexpr Line(const Point &a, const Point &b) : a(a), b(b) {}

        //线段长度
        constexpr double length() const {
            return (b - a).norm();
        }

        //求点到直线的距离
        //返回点到直线上最近的点，垂足
        constexpr Point pointToLine(const Point &p) const {
            Point direction = b - a;
            Point vector = p - a;

            // 使用向量的投影计算垂足的位置
            double t = (vector * direction) / direction.norm();
            return a + direction * (t / direction.norm());
        }

        constexpr double distance(const Point &p) const {
            return p.distance(pointToLine(p));
        }

        constexpr double distance(const Line &l) const {
            auto [result, intersectionPoint] = *this & l;
            if (result == 1) {
                return distance(l.a);
            } else if (result == 3) {
                return (a - l.a) * ((l.a - l.b) ^ (a - b)) / ((l.a - l.b) ^ (a - b)).norm();
            } else {
                return 0;
            }
        }

        //判断点在直线上
        constexpr bool pointOnLine(const Point &p) const {
            return sgn(distance(p)) == 0;
        }

        //两直线相交求交点
        //第一个值为0表示直线重合，为1表示平行,为2是相交，为3是相离
        //只有第一个值为2时，交点才有意义
        constexpr std::pair<int, Point> operator&(const Line &l) const {
            Point direction1 = b - a;
            Point direction2 = l.b - l.a;
            // 判断两直线是否平行
            Point crossProduct = direction1 ^ direction2;
            if (sgn(crossProduct.norm()) == 0) {
                // 平行或重合
                if (pointOnLine(l.a) && pointOnLine(l.b)) {
                    // 重合
                    return {0, Point()};
                } else {
                    // 平行
                    return {1, Point()};
                }
            }

            // 计算参数 t1 和 t2，使得两直线上的点满足参数方程
            double t1 = ((l.a - a) ^ direction2).norm() / crossProduct.norm();
            double t2 = ((a - l.a) ^ direction1).norm() / crossProduct.norm();
            // 计算交点
            Point intersectionPoint = a + direction1 * t1;
            if (!pointOnLine(intersectionPoint) || !l.pointOnLine(intersectionPoint)) {
                return {3, Point()};
            }
            return {2, intersectionPoint};
        }

        // 判断点p是否在线段上
        constexpr bool pointOnSeg(const Point &p) const {

            // 判断点到线段两端点的投影是否在线段上，且点到线段两端点的距离之和等于线段的长度
            return pointOnLine(p) && p.x >= min(a.x, b.x) && p.x <= max(a.x, b.x) && p.y >= min(a.y, b.y) &&
                   p.y <= max(a.y, b.y) && p.z >= min(a.z, b.z) && p.z <= max(a.z, b.z);
        }

        // 判断线段是否相交
        constexpr bool seg_inter_seg(const Seg &l) const {
            auto [result, intersectionPoint] = *this & l;

            if (result == 2) {
                // 两线段相交，再判断交点是否在两线段上
                return l.pointOnSeg(intersectionPoint) && pointOnSeg(intersectionPoint);
            }

            return false;
        }

        //判断直线与线段l是否相交
        constexpr bool line_inter_seg(const Seg &l) const {
            auto [result, intersectionPoint] = *this & l;

            if (result == 2) {
                // 两线段相交，再判断交点是否在线段上
                return l.pointOnSeg(intersectionPoint);
            }

            return false;
        }

        // 求点到线段的距离，返回点到线段最近的点
        constexpr Point nearestPointToSeg(const Point &p) const {
            Point vectorAP = p - a;
            Point vectorAB = b - a;

            // 计算点到线段的投影位置
            double t = (vectorAP * vectorAB) / vectorAB.norm();

            // 如果投影位置小于等于0，则最近的点是线段的起点a
            if (sgn(t) <= 0) {
                return a;
            }

            // 如果投影位置大于等于线段长度，则最近的点是线段的终点b
            if (sgn(t - vectorAB.norm()) >= 0) {
                return b;
            }

            // 否则，最近的点是线段上的投影点
            return a + vectorAB * (t / vectorAB.norm());
        }
    };

    class Plane {
    public:
        Point a, b, c;

        // 无参构造函数
        constexpr Plane() : a(), b(), c() {}

        // 有参构造函数
        constexpr Plane(const Point &a, const Point &b, const Point &c) : a(a), b(b), c(c) {}

        // 面到点的距离
        constexpr double distance(const Point &p) const {
            Point normal = (b - a) ^ (c - a);
            double d = -normal.x * a.x - normal.y * a.y - normal.z * a.z;
            return abs(normal.x * p.x + normal.y * p.y + normal.z * p.z + d) / normal.norm();
        }

        // 面到线的距离
        constexpr double distance(const Line &l) const {
            auto [res, intersectionPoint] = intersectWithLine(l);
            if (res != 0) {
                return 0;
            } else {
                return distance(l.a);
            }
        }

        // 面到面的距离
        constexpr double distance(const Plane &p) const {
            auto [res, intersectionPoint] = intersectWithPlane(p);
            if (res != 0) {
                return 0;
            } else {
                return distance(p.a);
            }
        }

        // 面和线的交点
        constexpr pair<int, Point> intersectWithLine(const Line &line) const {
            Point normal = (b - a) ^ (c - a);

            // 如果线和面平行，返回空点
            if (sgn((normal * (line.b - line.a)) == 0)) {
                return {0, Point()};
            }

            // 计算交点
            double t = -((normal.x * (line.a.x - a.x) + normal.y * (line.a.y - a.y) + normal.z * (line.a.z - a.z)) /
                         (normal * (line.b - line.a)));
            return {1, line.a + (line.b - line.a) * t};
        }

        // 面和面的交线，0为不存在，1为存在
        constexpr std::pair<int, Line> intersectWithPlane(const Plane &other) const {
            Point normal1 = (b - a) ^ (c - a);
            Point normal2 = (other.b - other.a) ^ (other.c - other.a);
            Point direction = normal1 ^ (normal2);

            // 如果两平面平行，返回空线段
            if (sgn(direction.norm()) == 0) {
                return {0, Line()};
            }

            // 选择交线上的一点
            Point pointOnLine = a;

            // 计算交线的方向
            Point lineDirection = normal1 ^ (direction);

            // 计算交线的终点
            Point endPoint = pointOnLine + lineDirection;

            return {1, Line(pointOnLine, endPoint)};
        }

    };
}
using namespace Dimension3;
//玩原神导致的
void genshin_start() {
    int x,y,z,r;
    cin >> x >> y >> z >> r;
    Point o(x,y,z);
    int x1,y1,z1,x2,y2,z2;
    cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;
    Point s(x1,y1,z1),t(x2,y2,z2);
    if(s.distance(t) == 0) {
        cout << 0 << endl;
        return;
    }
    Line myline(s,t);
    if(o.distance(myline.nearestPointToSeg(o))>=r){
        cout << myline.length()<< '\n';
        return;
    }
    double dis = o.distance(myline.pointToLine(o));
    if(dis >= r){;
        cout << myline.length()<< endl;
    }else {
        double res;
        if (s.distance(o) == r && t.distance(o) == r) {
            double sgm = acos(dis / r);
            res = 2 * r * (sgm);
        } else {
            double sgm0 = 0;
            sgm0 += acos(dis/s.distance(o));
            sgm0 += acos(dis/t.distance(o));
            double sgm1 = acos(r / s.distance(o));
            if(s.distance(o) == r) sgm1 = 0;
            double sgm2 = acos(r / t.distance(o));
            if(t.distance(o) == r) sgm2 = 0;
            res = r * (sgm0 - sgm1 - sgm2) + sqrt(s.distance(o) * s.distance(o) - r * r)
                         + sqrt(t.distance(o) * t.distance(o) - r * r);
        }
        cout << res << endl;
    }
}

signed main() {
    GKD;
    cout << fixed << setprecision(8);
    auto T = 1;
    cin >> T;
    while (T--) genshin_start();
    return 0;
}